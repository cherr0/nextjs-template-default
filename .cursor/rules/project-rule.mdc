---
description:
globs:
alwaysApply: true
---

# 프로젝트 룰

이 문서는 현재 프로젝트에서 따라야 할 주요 룰들을 정리한 것입니다.

## 폰트 크기 설정

**룰:** 루트 폰트 크기가 설정되어 있어서 1px이 1rem과 같습니다. px 단위를 rem으로 변환할 때는 단위만 변경하고 숫자 값은 그대로 유지합니다.

**이유:**

- 일관된 폰트 크기 시스템을 유지합니다.
- 반응형 디자인을 위한 기준점을 제공합니다.

**예시:**

```scss
// 잘못된 예시
font-size: 16px; // 숫자 값이 변경됨

// 올바른 예시
font-size: 16rem; // 숫자 값 유지
```

## 코딩 스타일 가이드

**룰:** `@CLAUDE.md` 스타일 가이드를 읽고 따라야 합니다.

**이유:**

- 일관된 코드 스타일을 유지합니다.
- 팀 협업 시 코드 가독성을 향상시킵니다.

## CSS 모듈 사용

**룰:** 프로젝트에서는 모듈 CSS만 사용해야 합니다.

**이유:**

- CSS 클래스명 충돌을 방지합니다.
- 컴포넌트별 스타일 격리를 보장합니다.
- 유지보수성을 향상시킵니다.

**예시:**

```tsx
// 올바른 사용법
import styles from './Component.module.scss'

function Component() {
  return <div className={styles.container}>내용</div>
}

// 잘못된 사용법
import './Component.css' // 일반 CSS 파일 사용 금지
```

## 패키지 매니저

**룰:** 의존성 설치 시 yarn을 사용해야 합니다.

**이유:**

- 프로젝트에서 yarn을 기본 패키지 매니저로 사용합니다.
- 일관된 의존성 관리를 보장합니다.

**예시:**

```bash
# 올바른 명령어
yarn add package-name
yarn remove package-name
yarn install

# 잘못된 명령어
npm install package-name
npm uninstall package-name
```

## 폴더 구조 규칙

**룰:** 기능별로 폴더를 구성하고, 공통 컴포넌트는 `src/components/common`에 배치합니다.

**이유:**

- 코드의 논리적 구조를 유지합니다.
- 기능별 개발 및 유지보수를 용이하게 합니다.

## 타입스크립트 사용

**룰:** 모든 새로운 코드는 TypeScript로 작성해야 합니다.

**이유:**

- 타입 안정성을 보장합니다.
- 개발 시 오류를 사전에 방지합니다.
- 코드 가독성과 유지보수성을 향상시킵니다.

## 컴포넌트 네이밍

**룰:** 컴포넌트 파일명은 PascalCase를 사용하고, 폴더명과 일치시킵니다.

**이유:**

- 일관된 네이밍 컨벤션을 유지합니다.
- 파일 탐색과 코드 이해를 용이하게 합니다.

**예시:**

```
Button/
├── Button.tsx
├── Button.module.scss
└── index.ts
```

## 스타일 파일 네이밍

**룰:** 스타일 파일은 컴포넌트명과 동일하게 작성하고 `.module.scss` 확장자를 사용합니다.

**이유:**

- 모듈 CSS 사용을 명확히 합니다.
- 컴포넌트와 스타일 파일의 관계를 명확히 합니다.

## 인덱스 파일 사용

**룰:** 각 컴포넌트 폴더에는 `index.ts` 파일을 생성하여 컴포넌트를 export합니다.

**이유:**

- 깔끔한 import 구문을 제공합니다.
- 컴포넌트 구조를 명확히 합니다.

**예시:**

```tsx
// index.ts
export { default } from './Button'
export * from './Button'
```

## 상수 관리

**룰:** 매직 넘버는 명명된 상수로 대체하여 명확성을 높입니다.

**이유:**

- 코드의 의미를 명확히 합니다.
- 유지보수성을 향상시킵니다.

**예시:**

```typescript
const ANIMATION_DELAY_MS = 300

async function onLikeClick() {
  await postLike(url)
  await delay(ANIMATION_DELAY_MS) // 애니메이션 대기 시간임을 명확히 표시
  await refetchPostLike()
}
```

## 복잡한 로직 추상화

**룰:** 복잡한 로직이나 상호작용은 전용 컴포넌트나 HOC로 추상화합니다.

**이유:**

- 관심사를 분리하여 인지 부하를 줄입니다.
- 컴포넌트의 가독성, 테스트 가능성, 유지보수성을 향상시킵니다.

## 조건부 렌더링 분리

**룰:** 상당히 다른 조건부 UI/로직은 별개의 컴포넌트로 분리합니다.

**이유:**

- 복잡한 조건문을 피하여 가독성을 향상시킵니다.
- 각 전문화된 컴포넌트가 명확하고 단일 책임을 가지도록 보장합니다.

## 복잡한 삼항 연산자 단순화

**룰:** 복잡하거나 중첩된 삼항 연산자는 `if`/`else` 또는 IIFE로 대체하여 가독성을 높입니다.

**이유:**

- 조건부 로직을 더 쉽게 따라갈 수 있게 합니다.
- 전반적인 코드 유지보수성을 향상시킵니다.

## 예측 가능성

**룰:** 함수나 훅의 반환 타입을 일관되게 사용합니다.

**이유:**

- 코드의 예측 가능성을 향상시킵니다.
- 개발자가 반환 값 형태를 예상할 수 있게 합니다.

## 숨겨진 로직 방지

**룰:** 숨겨진 부작용을 피하고, 함수는 시그니처에서 암시하는 동작만 수행해야 합니다.

**이유:**

- 의도하지 않은 부작용 없이 예측 가능한 동작을 만듭니다.
- 관심사 분리(SRP)를 통해 더 견고하고 테스트 가능한 코드를 만듭니다.

## 고유하고 설명적인 이름 사용

**룰:** 커스텀 래퍼/함수에 고유하고 설명적인 이름을 사용하여 모호함을 피합니다.

**이유:**

- 모호함을 피하고 예측 가능성을 향상시킵니다.
- 개발자가 이름에서 특정 동작(예: 인증 추가)을 직접 이해할 수 있게 합니다.

## 응집성

**룰:** 관련 코드를 함께 유지하고 모듈이 잘 정의된 단일 목적을 가지도록 합니다.

**이유:**

- 관련 파일을 함께 유지하여 응집성을 높입니다.
- 기능 이해, 개발, 유지보수, 삭제를 단순화합니다.

## 결합도 최소화

**룰:** 코드베이스의 다른 부분 간의 의존성을 최소화합니다.

**이유:**

- 불필요한 중간 의존성을 제거하여 결합도를 크게 줄입니다.
- 더 평평한 컴포넌트 트리에서 리팩토링을 쉽게 하고 데이터 흐름을 명확히 합니다.

## 상태 관리 범위 설정

**룰:** 광범위한 상태 관리를 더 작고 집중된 훅/컨텍스트로 분해합니다.

**이유:**

- 컴포넌트가 필요한 상태 조각에만 의존하도록 하여 결합도를 줄입니다.
- 관련 없는 상태 변경으로 인한 불필요한 리렌더링을 방지하여 성능을 향상시킵니다.

## Props Drilling 제거

**룰:** Props Drilling 대신 컴포넌트 합성을 사용합니다.

**이유:**

- 불필요한 중간 의존성을 제거하여 결합도를 크게 줄입니다.
- 더 평평한 컴포넌트 트리에서 리팩토링을 쉽게 하고 데이터 흐름을 명확히 합니다.
